/**
* Positioner lets you centralize and manage changes related to positioned elements. Positioner returns an utility that resolves positioning for all widget.
* @name Positioner
* @class Positioner
* @memberOf ch
* @param {Object} conf Configuration object with positioning properties.
* @param {String} conf.element Reference to the DOM Element to be positioned.
* @param {String} [conf.context] It's a reference to position and size of element that will be considered to carry out the position. If it isn't defined through configuration, it will be the viewport.
* @param {String} [conf.points] Points where element will be positioned, specified by configuration or center by default.
* @param {String} [conf.offset] Offset in pixels that element will be displaced from original position determined by points. It's specified by configuration or zero by default.
* @param {Boolean} [conf.reposition] Parameter that enables or disables reposition intelligence. It's disabled by default.
* @requires ch.Viewport
* @see ch.Viewport
* @returns {Function} The Positioner returns a Function that it works in 3 ways: as a setter, as a getter and with the "refresh" parameter refreshes the position.
* @exampleDescription
* Instance the Positioner It requires a little configuration.
* The default behavior place an element center into the Viewport.
*
* @example
* var positioned = ch.Positioner({
*     element: "#element1",
* });
* @exampleDescription 1. Getting the current configuration properties.
* @example
* var configuration = positioner()
* @exampleDescription 2. Updates the current position with <code>refresh</code> as a parameter.
* @example
* positioner("refresh");
* @exampleDescription 3. Define a new position
* @example
* positioner({
*     element: "#element2",
*     context: "#context2",
*     points: "lt rt"
* });
* @exampleDescription <strong>Offset</strong>: The Positioner could be configurated with an offset.
* This example show an element displaced horizontally by 10px of defined position.
* @example
* var positioned = new ch.Positioner({
*     element: "#element3",
*     context: "#context3",
*     points: "lt rt",
*     offset: "10 0"
* });
* @exampleDescription <strong>Reposition</strong>: RePositioner feature moves the postioned element if it can be shown into the viewport.
* @example
* var positioned = new ch.Positioner({
*     element: "#element4",
*     context: "#context4",
*     points: "lt rt",
*     reposition: true
* });
*/
(function (window, $, ch) {
    'use strict';

    if (ch === undefined) {
        throw new window.Error('Expected ch namespace defined.');
    }

    var $window = $(window),
        $html = $('html');

    function Positioner(options) {

        if (options === undefined) {
            throw new window.Error('ch.Positioner: Expected options defined.');
        }

        // Creates its private options
        this._options = ch.util.clone(this._defaults);

        // Init
        this.configure(options);

        return this;
    }

    Positioner.prototype.name = 'positioner';

    Positioner.prototype.constructor = Positioner;

    Positioner.prototype._defaults = {
        'offsetX': 0,
        'offsetY': 0,
        'side': 'center',
        'align': 'center',
        'reference': ch.viewport,
        'positioned': 'fixed'
    };

    Positioner.prototype.configure = function (options) {

        // Merge user options with its options
        $.extend(this._options, options);

        this._options.offsetX = parseInt(this._options.offsetX, 10);
        this._options.offsetY = parseInt(this._options.offsetY, 10);
        this.$target = options.target || this.$target;
        this.$reference = options.reference || this.$reference;
        this._reference = this._options.reference;

        this.$target.css('position', this._options.positioned);

        return this;
    };

    Positioner.prototype.refresh = function (options) {
        if (options !== undefined) {
            this.configure(options);
        }

         if (this._reference !== ch.viewport) {
            this._calculateReference();
        }

        this._calculateTarget();

        // the object that stores the top, left reference to set to the target
        this._setPoint();

        return this;
    };

    Positioner.prototype._calculateReference = function () {

        var $reference = this.$reference.attr({
                'data-side': this._options.side,
                'data-align': this._options.align
            }),
            reference = $reference[0],
            outer = ch.util.getOuterDimensions(reference),
            offset = ch.util.getOffset(reference);

        this._reference = {
            'width': outer.width,
            'height': outer.height
        };

        if (reference.offsetParent === this.$target[0].offsetParent) {
            this._reference.left = reference.offsetLeft;
            this._reference.top = reference.offsetTop;
        } else {
            this._reference.left = offset.left;
            this._reference.top = offset.top;
        }

        return this;
    };

    Positioner.prototype._calculateTarget = function ($target) {

        var $target = this.$target.attr({
                'data-side': this._options.side,
                'data-align': this._options.align
            }),
            outer = ch.util.getOuterDimensions($target[0]);

        this._target = {
            'width': outer.width,
            'height': outer.height
        };

        return this;
    };

    Positioner.prototype._setPoint = function () {
        var side = this._options.side,
            oritentation = (side === 'top' || side === 'bottom') ? 'horizontal' : ((side === 'right' || side === 'left') ? 'vertical' : 'center'),
            coors,
            oritentationMap;

        // take the side and calculate the alignment and make the CSSpoint
        if (oritentation === 'center') {
            // calculates the coordinates related to the center side to locate the target
            coors = {
                'top': (this._reference.top + (this._reference.height / 2 - this._target.height / 2)),
                'left': (this._reference.left + (this._reference.width / 2 - this._target.width / 2))
            };

        } else if (oritentation === 'horizontal') {
            // calculates the coordinates related to the top or bottom side to locate the target
            oritentationMap = {
                'left': this._reference.left,
                'center': (this._reference.left + (this._reference.width / 2 - this._target.width / 2)),
                'right': (this._reference.left + this._reference.width - this._target.width),
                'top': this._reference.top - this._target.height,
                'bottom': (this._reference.top + this._reference.height)
            };

            coors = {
                'top': oritentationMap[side],
                'left': oritentationMap[this._options.align]
            }

        } else {
            // calculates the coordinates related to the right or left side to locate the target
            oritentationMap = {
                'top': this._reference.top,
                'center': (this._reference.top + (this._reference.height / 2 - this._target.height / 2)),
                'bottom': (this._reference.top + this._reference.height - this._target.height),
                'right': (this._reference.left + this._reference.width),
                'left': (this._reference.left - this._target.width)
            };

            coors = {
                'top': oritentationMap[this._options.align],
                'left': oritentationMap[side]
            }
        }

        coors.top += this._options.offsetY;
        coors.left += this._options.offsetX;

        this.$target.css(coors);

        return this;
    };

    ch.Positioner = Positioner;

}(this, this.ch.$, this.ch));