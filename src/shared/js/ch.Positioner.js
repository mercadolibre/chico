(function (window, $, ch) {
    'use strict';

    /**
     * Positioner lets you centralize and manage changes related to positioned elements. Positioner returns an utility that resolves positioning for all widget.
     * @memberof ch
     * @constructor
     * @param {Object} options Configuration object with positioning properties.
     * @param {String} options.element Reference to the DOM Element to be positioned.
     * @param {String} [options.context] It's a reference to position and size of element that will be considered to carry out the position. If it isn't defined through configuration, it will be the viewport.
     * @param {String} [options.points] Points where element will be positioned, specified by configuration or center by default.
     * @param {String} [options.offset] Offset in pixels that element will be displaced from original position determined by points. It's specified by configuration or zero by default.
     * @param {Boolean} [options.reposition] Parameter that enables or disables reposition intelligence. It's disabled by default.
     * @requires ch.Viewport
     * @see ch.Viewport
     * @returns {Function} The Positioner returns a Function that it works in 3 ways: as a setter, as a getter and with the "refresh" parameter refreshes the position.
     *
     * @exampleDescription
     * Instance the Positioner It requires a little configuration.
     * The default behavior place an element center into the Viewport.
     *
     * @example
     * var positioned = ch.Positioner({
     *     element: "#element1",
     * });
     * @exampleDescription 1. Getting the current configuration properties.
     * @example
     * var configuration = positioner()
     * @exampleDescription 2. Updates the current position with <code>refresh</code> as a parameter.
     * @example
     * positioner("refresh");
     * @exampleDescription 3. Define a new position
     * @example
     * positioner({
     *     element: "#element2",
     *     context: "#context2",
     *     points: "lt rt"
     * });
     * @exampleDescription <strong>Offset</strong>: The Positioner could be configurated with an offset.
     * This example show an element displaced horizontally by 10px of defined position.
     * @example
     * var positioned = new ch.Positioner({
     *     element: "#element3",
     *     context: "#context3",
     *     points: "lt rt",
     *     offset: "10 0"
     * });
     * @exampleDescription <strong>Reposition</strong>: RePositioner feature moves the postioned element if it can be shown into the viewport.
     * @example
     * var positioned = new ch.Positioner({
     *     element: "#element4",
     *     context: "#context4",
     *     points: "lt rt",
     *     reposition: true
     * });
     */
    function Positioner(options) {

        if (options === undefined) {
            throw new window.Error('ch.Positioner: Expected options defined.');
        }

        // Creates its private options
        this._options = ch.util.clone(this._defaults);

        // Init
        this.configure(options);

        return this;
    }


    /**
     * All instances are saved into a 'map', grouped by its name. You can reach for any or all of the components from a specific name with 'ch.instances'.
     * @memberof! ch.Positioner.prototype
     * @type {String}
     */
    Positioner.prototype.name = 'positioner';

    /**
     * Returns a reference to the Constructor function that created the instance's prototype.
     * @memberof! ch.Widget.prototype
     * @function
     */
    Positioner.prototype.constructor = Positioner;

    /**
     * Configuration by default.
     * @private
     * @type {Object}
     */
    Positioner.prototype._defaults = {
        'offsetX': 0,
        'offsetY': 0,
        'side': 'center',
        'align': 'center',
        'reference': ch.viewport,
        'positioned': 'fixed'
    };

    /**
     * Configures the positioner instance with a given options.
     * @type {instance}
     * @params {Object} options A configuration object.
     */
    Positioner.prototype.configure = function (options) {

        // Merge user options with its options
        $.extend(this._options, options);

        this._options.offsetX = parseInt(this._options.offsetX, 10);
        this._options.offsetY = parseInt(this._options.offsetY, 10);
        this.$target = options.target || this.$target;
        this.$reference = options.reference || this.$reference;
        this._reference = this._options.reference;

        this.$target.css('position', this._options.positioned);

        return this;
    };

    /**
     * Updates the current position with a given options
     * @type {instance}
     * @params {Object} options A configuration object.
     */
    Positioner.prototype.refresh = function (options) {

        if (options !== undefined) {
            this.configure(options);
        }

         if (this._reference !== ch.viewport) {
            this._calculateReference();
        }

        this._calculateTarget();

        // the object that stores the top, left reference to set to the target
        this._setPoint();

        return this;
    };

    /**
     * Calculates the reference (element or viewport) of the position.
     * @type {instance}
     * @private
     */
    Positioner.prototype._calculateReference = function () {

        var reference = this.$reference[0],
            offset;

        reference.setAttribute('data-side', this._options.side);
        reference.setAttribute('data-align', this._options.align);

        this._reference = ch.util.getOuterDimensions(reference);

        if (reference.offsetParent === this.$target[0].offsetParent) {
            this._reference.left = reference.offsetLeft;
            this._reference.top = reference.offsetTop;

        } else {
            offset = ch.util.getOffset(reference);
            this._reference.left = offset.left;
            this._reference.top = offset.top;
        }

        return this;
    };

    /**
     * Calculates the positioned element.
     * @type {instance}
     * @private
     * @params {Selector} $target A given selector.
     */
    Positioner.prototype._calculateTarget = function ($target) {

        var target = this.$target[0];
        target.setAttribute('data-side', this._options.side);
        target.setAttribute('data-align', this._options.align);

        this._target = ch.util.getOuterDimensions(target);

        return this;
    };

    /**
     * Calculates the points.
     * @type {instance}
     * @private
     */
    Positioner.prototype._setPoint = function () {
        var side = this._options.side,
            oritentation = (side === 'top' || side === 'bottom') ? 'horizontal' : ((side === 'right' || side === 'left') ? 'vertical' : 'center'),
            coors,
            oritentationMap;

        // take the side and calculate the alignment and make the CSSpoint
        if (oritentation === 'center') {
            // calculates the coordinates related to the center side to locate the target
            coors = {
                'top': (this._reference.top + (this._reference.height / 2 - this._target.height / 2)),
                'left': (this._reference.left + (this._reference.width / 2 - this._target.width / 2))
            };

        } else if (oritentation === 'horizontal') {
            // calculates the coordinates related to the top or bottom side to locate the target
            oritentationMap = {
                'left': this._reference.left,
                'center': (this._reference.left + (this._reference.width / 2 - this._target.width / 2)),
                'right': (this._reference.left + this._reference.width - this._target.width),
                'top': this._reference.top - this._target.height,
                'bottom': (this._reference.top + this._reference.height)
            };

            coors = {
                'top': oritentationMap[side],
                'left': oritentationMap[this._options.align]
            }

        } else {
            // calculates the coordinates related to the right or left side to locate the target
            oritentationMap = {
                'top': this._reference.top,
                'center': (this._reference.top + (this._reference.height / 2 - this._target.height / 2)),
                'bottom': (this._reference.top + this._reference.height - this._target.height),
                'right': (this._reference.left + this._reference.width),
                'left': (this._reference.left - this._target.width)
            };

            coors = {
                'top': oritentationMap[this._options.align],
                'left': oritentationMap[side]
            }
        }

        coors.top += this._options.offsetY;
        coors.left += this._options.offsetX;

        this.$target.css(coors);

        return this;
    };

    ch.Positioner = Positioner;

}(this, this.ch.$, this.ch));